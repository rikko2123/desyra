# La CI crea un ambiente di test temporaneo, valida la configurazione,
# avvia lo stack Docker e fallisce immediatamente se qualcosa non Ã¨ corretto.
# Nessun deploy avviene a questo livello

#avvia macchina temporanea 
name: Build and Push Docker Image

#trigger sulle push al branch manster
on:
  push:
    branches: [ master ]
    #solo in caso in cui vengono toccati file all'interno di queste dir core dell'infrastruttura
    paths:
      - "back_end_desyra/app/*"
      - "infra/**"
      - ".github/workflows/**"

#estraggo i metadati dalla repo GIT
jobs:
  integration-test:
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - name: Checkout #clono git repo con checkout
        uses: actions/checkout@v4
      # valido env var e secrets
      - name: Validate required env variables
        env:
          DB_HOST: ${{ vars.DATABASE_HOST }}
          DB_USER: ${{ vars.DATABASE_USERNAME }}
          DB_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          DB_PORT: ${{ vars.DATABASE_PORT }}
          DB_NAME: ${{ vars.DATABASE_NAME }}
          DB_ROOT_PASSWORD: ${{ secrets.DATABASE_ROOT_PASSWORD }}

        # creo script bash che mi valida le env 
        # itero per le env che ho definito nel job
        # con -z al valore della variabile verifico che no sia vuota
        # nel caso blocco flusso esecuzione test
        run: |
          echo "[+] Carico var d'ambiente...."
          for v in DB_HOST DB_USER DB_PASSWORD DB_PORT DB_NAME DB_ROOT_PASSWORD; do
            if [ -z "${!v}" ]; then
              echo "[+] Variabile ${v} non trovata/non corretta... :("
              exit 1
            fi 
          done 
          echo "[+] Tutte var corrette e settate"

      #una volta validato le env creo file da passare al compose
      - name: Create .env file
        env:
          DB_HOST: ${{ vars.DATABASE_HOST }}
          DB_USER: ${{ vars.DATABASE_USERNAME }}
          DB_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          DB_PORT: ${{ vars.DATABASE_PORT }}
          DB_NAME: ${{ vars.DATABASE_NAME }}
          DB_ROOT_PASSWORD: ${{ secrets.DATABASE_ROOT_PASSWORD }}

        run: |
          touch ./infra/.env
          {
            echo "MYSQL_ROOT_PASSWORD=$DB_ROOT_PASSWORD"
            echo "MYSQL_DATABASE=$DB_NAME"
            echo "MYSQL_USER=$DB_USER"
            echo "MYSQL_PASSWORD=$DB_PASSWORD"

            echo "DATABASE_HOST=$DB_HOST"
            echo "DATABASE_USERNAME=$DB_USER"
            echo "DATABASE_PASSWORD=$DB_PASSWORD"
            echo "DATABASE_NAME=$DB_NAME"
            echo "DATABASE_PORT=$DB_PORT"
            echo "DATABASE_ROOT_PASSWORD=$DB_ROOT_PASSWORD"
          } > ./infra/.env

          echo "[+] Generato .env file....."

      #auth con token docker
      - name: Extract Docker image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ vars.DOCKER_USERNAME }}/my-image
      - name: Log in to Docker Hub #log in a docker hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # AVVIO DOCKER (ambiente di test)
      # controllo se risponde l'endpoint healt, se non 200 exit
      - name: Start containers
        run: |
          set -euo pipefail
          cd infra
          docker compose -f compose.ci.yml up -d --build
          for i in {1..20}; do
            out=$(curl -w "%{http_code}" -o /dev/null -s http://localhost:8000/health/ || true)
            if [ "$out" -eq 200 ]; then
              echo "[+] Backend pronto..... tutto in check! DAJE"
              exit 0
            else
              echo "[+] Status code: $out"
              echo "[+] Retry n... ${i}/20"
              sleep 5
            fi
          done
          echo "[+] Backend non raggiungibile.... :("
          exit 1
          

      

